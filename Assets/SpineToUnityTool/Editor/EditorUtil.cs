// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Text;
using System.IO;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
#if UNITY_4_0_0 ||UNITY_4_0 || UNITY_4_0_1||UNITY_4_1||UNITY_4_2||UNITY_4_3||UNITY_4_4||UNITY_4_5||UNITY_4_6||UNITY_4_7||UNITY_4_8||UNITY_4_9
namespace OnePStudio.SpineToUnity4
#else
namespace OnePStudio.SpineToUnity5
#endif
{
	public class EditorUtil
	{
		public class AnimationClipSettings
		{
			SerializedProperty m_Property;
			
			private SerializedProperty Get (string property) { return m_Property.FindPropertyRelative(property); }
			
			public AnimationClipSettings(SerializedProperty prop) { m_Property = prop; }
			
			public float startTime   { get { return Get("m_StartTime").floatValue; } set { Get("m_StartTime").floatValue = value; } }
			public float stopTime	{ get { return Get("m_StopTime").floatValue; }  set { Get("m_StopTime").floatValue = value; } }
			public float orientationOffsetY { get { return Get("m_OrientationOffsetY").floatValue; } set { Get("m_OrientationOffsetY").floatValue = value; } }
			public float level { get { return Get("m_Level").floatValue; } set { Get("m_Level").floatValue = value; } }
			public float cycleOffset { get { return Get("m_CycleOffset").floatValue; } set { Get("m_CycleOffset").floatValue = value; } }
			
			public bool loopTime { get { return Get("m_LoopTime").boolValue; } set { Get("m_LoopTime").boolValue = value; } }
			public bool loopBlend { get { return Get("m_LoopBlend").boolValue; } set { Get("m_LoopBlend").boolValue = value; } }
			public bool loopBlendOrientation { get { return Get("m_LoopBlendOrientation").boolValue; } set { Get("m_LoopBlendOrientation").boolValue = value; } }
			public bool loopBlendPositionY { get { return Get("m_LoopBlendPositionY").boolValue; } set { Get("m_LoopBlendPositionY").boolValue = value; } }
			public bool loopBlendPositionXZ { get { return Get("m_LoopBlendPositionXZ").boolValue; } set { Get("m_LoopBlendPositionXZ").boolValue = value; } }
			public bool keepOriginalOrientation { get { return Get("m_KeepOriginalOrientation").boolValue; } set { Get("m_KeepOriginalOrientation").boolValue = value; } }
			public bool keepOriginalPositionY { get { return Get("m_KeepOriginalPositionY").boolValue; } set { Get("m_KeepOriginalPositionY").boolValue = value; } }
			public bool keepOriginalPositionXZ { get { return Get("m_KeepOriginalPositionXZ").boolValue; } set { Get("m_KeepOriginalPositionXZ").boolValue = value; } }
			public bool heightFromFeet { get { return Get("m_HeightFromFeet").boolValue; } set { Get("m_HeightFromFeet").boolValue = value; } }
			public bool mirror { get { return Get("m_Mirror").boolValue; } set { Get("m_Mirror").boolValue = value; } }
		}

		static public UnityEngine.Color HexToColor(string hex)
		{
			try
			{
				byte r = byte.Parse(hex.Substring(0,2), System.Globalization.NumberStyles.HexNumber);
				byte g = byte.Parse(hex.Substring(2,2), System.Globalization.NumberStyles.HexNumber);
				byte b = byte.Parse(hex.Substring(4,2), System.Globalization.NumberStyles.HexNumber);
				byte a = byte.Parse(hex.Substring(6,2), System.Globalization.NumberStyles.HexNumber);

				return new UnityEngine.Color(r/255.0f,g/255.0f,b/255.0f, a/255.0f);
			}
			catch(System.Exception ex)
			{
				return new UnityEngine.Color(1,1,1,1);
			}
		}
		public static List<string> LoadStringByLine(string text)
		{
			List<string> listLine = new List<string> ();
			string [] temp=text.Split(new string[]{ "\n"},StringSplitOptions.None);
			listLine.AddRange(temp);
			return listLine;
		}

		public static List<string> Load(string fileName)
		{
			List<string> listLine = new List<string> ();
			// Handle any problems that might arise when reading the text
			try
			{
				string line;
				// Create a new StreamReader, tell it which file to read and what encoding the file
				// was saved as
				StreamReader theReader = new StreamReader(fileName, Encoding.Default);
				
				// Immediately clean up the reader after this block of code is done.
				// You generally use the "using" statement for potentially memory-intensive objects
				// instead of relying on garbage collection.
				// (Do not confuse this with the using directive for namespace at the 
				// beginning of a class!)
				using (theReader)
				{
					// While there's lines left in the text file, do this:
					do
					{
						
						line = theReader.ReadLine();

						if (line != null)
						{
							listLine.Add(line);
						}
					}
					while (line != null);
					// Done reading, close the reader and return true to broadcast success    
					theReader.Close();
				}
			}
			
			catch (Exception e)
			{
				Debug.Log("{0}\n"+ e.Message);
			}
			return listLine;
		}
		public static string LoadAllFileToString(string fileName)
		{
			string content="";
			// Handle any problems that might arise when reading the text
			try
			{
				// Create a new StreamReader, tell it which file to read and what encoding the file
				// was saved as
				StreamReader theReader = new StreamReader(fileName, Encoding.Default);
				
				// Immediately clean up the reader after this block of code is done.
				// You generally use the "using" statement for potentially memory-intensive objects
				// instead of relying on garbage collection.
				// (Do not confuse this with the using directive for namespace at the 
				// beginning of a class!)
				using (theReader)
				{
					content = theReader.ReadToEnd();
					// Done reading, close the reader and return true to broadcast success    
					theReader.Close();
				}
			}
			
			catch (Exception e)
			{
				Debug.Log("{0}\n"+ e.Message);
			}
			return content;
		}
		public static string AnimatorInfoJson()
		{
			string str="";
			str="{\"rootPosition\":{\"x\":0,\"y\":0,\"z\":0},\"rootRotation\":{\"eulerAngles\":{\"x\":0,\"y\":0,\"z\":0},\"x\":0,\"y\":0,\"z\":0,\"w\":1},\"applyRootMotion\":false,\"linearVelocityBlending\":false,\"animatePhysics\":false,\"updateMode\":\"Normal\",\"bodyPosition\":{\"x\":0,\"y\":0,\"z\":0},\"bodyRotation\":{\"eulerAngles\":{\"x\":270,\"y\":null,\"z\":0},\"x\":0,\"y\":0,\"z\":null,\"w\":9.183409E-41},\"stabilizeFeet\":false,\"feetPivotActive\":1,\"speed\":1,\"cullingMode\":\"AlwaysAnimate\",\"playbackTime\":-1,\"recorderStartTime\":-1,\"recorderStopTime\":-1,\"runtimeAnimatorController\":{\"layers\":[{\"name\":\"Base Layer\",\"stateMachine\":{\"states\":[],\"stateMachines\":[],\"defaultState\":null,\"anyStatePosition\":{\"x\":50,\"y\":20,\"z\":0},\"entryPosition\":{\"x\":50,\"y\":120,\"z\":0},\"exitPosition\":{\"x\":800,\"y\":120,\"z\":0},\"parentStateMachinePosition\":{\"x\":800,\"y\":20,\"z\":0},\"anyStateTransitions\":[],\"entryTransitions\":[],\"behaviours\":[],\"name\":\"Base Layer\",\"hideFlags\":\"HideInHierarchy\"},\"avatarMask\":null,\"blendingMode\":\"Override\",\"syncedLayerIndex\":-1,\"iKPass\":false,\"defaultWeight\":0,\"syncedLayerAffectsTiming\":false}],\"parameters\":[],\"name\":\"AEP Animation\",\"hideFlags\":\"None\"},\"avatar\":null,\"layersAffectMassCenter\":false,\"logWarnings\":true,\"fireEvents\":true,\"enabled\":true,\"tag\":\"Untagged\",\"name\":\"AEP Animation\",\"hideFlags\":\"None\"}";
			return str;
		}
		public static int GetAlignment(Vector2 vec)
		{
			int alignment=9;
			float epsilon=0.0001f;
			if(Mathf.Abs(vec.x-0.5f)<epsilon&&Mathf.Abs(vec.y-0.5f)<epsilon)//center
			{
				alignment=0;
			}
			else if(Mathf.Abs(vec.x)<epsilon&&Mathf.Abs(vec.y-1)<epsilon)//top left
			{
				alignment=1;
			}
			else if(Mathf.Abs(vec.x-0.5f)<epsilon&&Mathf.Abs(vec.y-1)<epsilon)//top
			{
				alignment=2;
			}
			else if(Mathf.Abs(vec.x-1)<epsilon&&Mathf.Abs(vec.y-1)<epsilon)//top Right
			{
				alignment=3;
			}
			else if(Mathf.Abs(vec.x-0)<epsilon && Mathf.Abs(vec.y-0.5f)<epsilon)//left
			{
				alignment=4;
			}
			else if(Mathf.Abs(vec.x-1)<epsilon&&Mathf.Abs(vec.y-0.5f)<epsilon)//left
			{
				alignment=5;
			}
			else if(Mathf.Abs(vec.x-0)<epsilon&&Mathf.Abs(vec.y-0)<epsilon)// bottom left
			{
				alignment=6;
			}
			else if(Mathf.Abs(vec.x-0.5f)<epsilon&&Mathf.Abs(vec.y-0)<epsilon)//bottom
			{
				alignment=7;
			}
			else if(Mathf.Abs(vec.x-1)<epsilon&&Mathf.Abs(vec.y-0)<epsilon)//bottom right
			{
				alignment=8;
			}
			else//custom
			{
				alignment=9;
			}
			return alignment;
		}
		static public string GetFullPathBone(Transform boneRoot,Transform current)
		{
			string fullPath=current.name;
			Transform tran=current;
			while(true)
			{
				if(tran.parent==null||tran.parent==boneRoot)
				{
					break;
				}
				else
				{
					fullPath=tran.parent.name+"/"+ fullPath;
					tran=tran.parent;
				}
			}
			return fullPath;
		}

		static public GameObject GetObjectInFullPath(GameObject boneRoot,string path)
		{
			if(path.Length<1)
			{
				return boneRoot;
			}
			else
			{
				string[] sub=path.Split(new char[]{'/'});
				GameObject obj=boneRoot;
				for(int i=0;i<sub.Length;i++)
				{
					Transform trans=obj.transform.Find(sub[i]);
					if(trans!=null)
					{
						obj=trans.gameObject;
					}
					else
					{
						return null;
					}
				}
				return obj;
			}
		}

		/*private int[] AddSubmesh (Material material,int[] triangleInput, bool flip, string type) {
			//Submesh submesh = new Submesh();
			int[] triangles = new int[triangleInput.Length];
			int triangleCount=triangleInput.Length;
			int trianglesCapacity = triangles.Length;
			int firstVertex=0;
			int triangleIndex=0;
			if (flip) {
				for (int ii = 0, nn = triangleInput.Length; ii < nn; ii += 3, triangleIndex += 3) {
					triangles[triangleIndex + 2] = firstVertex + triangleIndex[ii];
					triangles[triangleIndex + 1] = firstVertex + triangleIndex[ii + 1];
					triangles[triangleIndex] = firstVertex + triangleIndex[ii + 2];
				}
			} else {
				for (int ii = 0, nn = triangleInput.Length; ii < nn; ii++, triangleIndex++) {
					triangles[triangleIndex] = firstVertex + triangleInput[ii];
				}
			}
			return triangles;
		}*/

	}
}

